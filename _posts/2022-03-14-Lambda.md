---
layout: single
title:  "람다 표현식"
published: true
categories: JAVA
tag: [Java, java_lambda]
toc: true
---

# 람다 표현식

## 람다란 무엇인가?

- 메서드로 전달할 수 있는 익명 함수를 단순화한 것 이라고 할 수 있다.



#### 람다의 특징

1. 익명: 보통의 메서드와 달리 이름이 없어 **익명**이라 표현한다.
2. 함수:메서드처럼 특정 클래스에 종속되지 않아 함수라 부른다. 하지만 메서드처럼 파라미터 리스트, 바디, 반환 형식, 가능한 예외 리스트를 포함한다.
3. 전달: 람다 표현식을 메서드 인수로 전달하거나 변수로 저장할 수 있다.
4. 간결성: 익명 클래스처럼 많은 자질구레한 코드를 구현할 필요가 없다.



예를 들어 Comparator객체를 간단하게 구현할주 있다

기존코드

| 사용 사례          | 람다 예제                                                    |
| :----------------- | ------------------------------------------------------------ |
| boolean 표현식     | (List<String> list) ->list.isEmpty()                         |
| 객체생성           | () -> new Apple(10)                                          |
| 객체에서 소비      | (Apple a) -> {<br />       System.out.println(a.getWeight());<br />} |
| 객체에서 건택/추출 | (String s) -> a.length()                                     |
| 두 값을 조합       | (int a, int b) -> a* b                                       |
| 두 객체 비교       | (Apple a1, Apple a2) -><br />       a1.getWeight().compareTo(a2.getWeight()) |



## 람다 활용 : 실행 어라운드 패턴

 자원 처리(예를 들면 DB의 파일 처리)에 사용하는 순환 패턴(recurrent pattern)은 자원을 열고, 처리한 다음에, 자원을 닫는 순서로 이루어진다.

**실행 어라운드 패턴**(execute around pattern): 초기화/준비 코드 -> 작업 -> 정리/마무리코드

-> 준비코드와 정리코드는 중복이 된다(준비-> 작업A ->정리, 준비->작업B->정리)

자원에서 한 행을 읽어오는 코드는 다음과 같다

```java
  public static String processFileLimited() throws IOException {
    try (BufferedReader br =
                 new BufferedReader(new FileReader(FILE))) {
      //try~~ 파일에서 한 행을 읽는 코드(자바7 try~with~resource)
      return br.readLine();  //실제 필요한 작업을 하는 행
    } //현재코드는 한번에 한 줄만 읽을 수 있음
  }
```



### 1단계 : 동작 파라미터화

* 한 번에 두줄을 읽거나 자주 사용되는 단어를 반환하고자 한다면 processFile의 동작을 파라미터화 해야한다. -> processFile 메서드가 BufferedReader를 이용하여 다른 동작을 수행할 수 있도록 processFile메서드로 동작을 전달해야 한다

```java
String twoLines = processFile((BufferedReader b) -> b.readLine() + b.readLine());
//BufferedReader를 인수로 받아서 String을 반환하는 람다
//두행을 처리하는 코드
```



### 2단계 : 함수형 인터페이스를 이용해서 동작 전달

* BufferedReader -> String과 IOException을 throw 할 수 있는 시그니처와 일치하는 함수형 인터페이스를 만들어야 한다

```java
@FunctionalInterface
public interface BufferedReaderProcessor {
    String process(BufferedReader b) throws IOException;
}
```



### 3단계 : 동작 실행

* 위에 정의한 인터페이스를 processFile 메서드의 인수로 전달 한다

```java
public static String processFile(BufferedReaderProcessor p) throws IOException {
    try (BufferedReader br =
               new BufferedReader(new FileReader(FILE))) {
    return p.process(br);    //BufferedReader 객체 처리
  }
}
```



### 4단계 : 람다 전달

* 람다를 이용하여 다양한 동작을 processFile 메서드로 전달할 수 있다.

```java
public static void main(String... args) throws IOException {
                        //...: 가변인자로 여러개의 매개변수를 받을 수 있다는 의미
    String result = processFileLimited();
    System.out.println(result);
	//람다 사용전
    System.out.println("---");

    String oneLine = processFile((BufferedReader b) -> b.readLine());
    System.out.println(oneLine);
    //한 행을 처리하는 코드

    String twoLines = 
        processFile((BufferedReader b) -> b.readLine() + "\n" + b.readLine());
    System.out.println(twoLines);
    //두행을 처리하는 코드
}
```

| data.txt                                         | 실행결과                              |
| ------------------------------------------------ | ------------------------------------- |
| Java <br />8 <br />Lambdas <br />In <br />Action | Java<br/>---<br/>Java<br/>Java<br />8 |

